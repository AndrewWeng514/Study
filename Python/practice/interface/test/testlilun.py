# -*- coding: utf-8 -*-
"""
@author: ZJ
@email: 1576094876@qq.com
@File : testlilun.py
@desc: 
@Created on: 2022/9/19 9:26
"""

"""
接口测试
接口测试理论  requests  pytest 其他

什么是接口测试
    本质就是通过工具或者代码 模拟发送接口请求  检测接口的请求和响应
    接口测试检查的重点:
        参数传递的正确性
        功能实现的正确性 
        输出结果的正确性
        异常容错 
    
    接口测试属于灰盒测试  接口测试可以从数量层面 表示接口测试属于单元测试的一个子集   他的粒度更粗 
    接口测试就是直接基于系统暴露出来的接口进行测试

为什么要做接口测试
    金字塔模型 橄榄模型  https://blog.csdn.net/lijing742180/article/details/90789932
    1.接口测试不需要依赖前端页面 可以定位 ui层面定位不了的bug
    2.测试前移,开发后台接口写完 理论上测试就可以通过工具或者代码进行接口测试
    4.提前定位bug 解决bug 避免时间浪费
    5.接口测试的效率更高 成本更低 速度更快

MVC三层架构
    M model 模型层/数据库   V view 视图层/页面显示层  C control 控制器/逻辑控制器 
    mvc优势 
        每一层只做这一层该做的事 分工明确 方便后期维护 责任追踪
        有利于 同步开发 效率提高 进度加快
        有利于系统移植 B/S(browser/server) 很容易改查 C/S
        一层一层传递 无法跨层接收数据 更安全
        
    mvc缺点
        效率低

web交互流程
    见笔记图片
url 
    统一资源定位符  uniform resource location
    ip确定唯一一台电脑  端口确定电脑上唯一一个服务  
    可以通过url定位到互联网上对应资源
    url的构成
        1.协议  常见的协议有 http https smtp ws wss  ftp
        2.域名/ip 
            域名就是ip的别名 ip是由数字构成 可读性差 记忆性差
            通过域名或者ip就可以确定唯一一个服务器
        3.端口
            通过端口确定唯一一个服务
            https 默认端口 443
            http 默认端口 80
        4.资源路径
            通过资源路径确定具体的服务器上的资源 默认 / 表示根路径
        5.附加部分(可有可无)
            参数部分 url中?后面接查询字符串参数 格式  键=值&键2=值2&。。。。

fiddler工具使用
   fiddler是一款专业的抓包(抓取请求数据包)软件
   工作原理: fiddler是充当一个中间代理  实现数据抓包
   filter  实现接口的过滤
   inspector  检查 针对指定接口检查详情
   autoresponder  自定义响应  设置规则 后续如果请求符合规则 会返回自己定义的响应
   composer  快速构建响应 常用于分析请求数据包的结构 快速组织参数重新发起请求
   fiddler如何打断点
     
http协议
    http请求通常由请求数据包和响应数据包共同构成一个请求
    
    请求数据包的构成
        第一部分  第一行 交代 请求方式 请求地址 协议类型
        第二部分  交代请求头信息  格式 键:值 
        第三部分  空行
        第四部分  请求正文 
        
    响应数据包的构成
        第一部分  交代协议类型  状态码
        第二部分  交代响应头信息  格式 键:值 
        第三部分  空行
        第四部分  响应正文

    http协议又称 超文本传输协议 （Hyper Text Transfer Protocol，HTTP） 属于应用层协议
    
    HTTP协议特点:
        支持客户端服务器模式 B/S
        通讯方式灵活(支持多种请求方式 支持多种文件类型传输)
        
        无连接
            每次请求连接成功之后 服务器都会处理当前请求并返回响应 响应结束断开连接 后续有新的请求重新连接
            设计之初 采用该特性 目的: 防止很多请求连接后不断开 会占用服务器端资源
            但是随着互联网的发展 样式 js 图片等交互 越来越多 导致访问一个网站需要加载很多的附加资源 
            如果附加资源也重新建立连接 会造成时间浪费资源浪费
            所以后面http协议默认 头部信息中  设置 Connection: keep-alive  即保持连接的意思
            那么后续的资源请求 不需要在频繁三次握手建立连接 直接采用现有连接访问
            一般设置它不是代表真正意义上长连接 而是表示当前连接会持续保持 100s（具体看不同浏览器） 后续当前地址的请求 使用现有连接
            
            websocket协议 是真正意义上的长连接协议(只要一方不断开 就能一直保持连接)
            http和websocket区别
                http是无连接       websocket是长连接
                http是单工(单向)协议      websocket是全双工(既可以客户端发给服务器 也可以服务器发给客户端)
                websocket是通过http请求跟服务器建立连接 后续和http没有任何关联 
                 
        无状态
            每个请求相互独立 后面的请求不知道前面请求发生的内容 两个请求之间没有任何的关联性
            现在很多的网站都有权限验证(身份验证机制) 如果无状态 会造成 第一个接口登陆 后续的接口依然不知道登陆状态(互相独立)
            所以产生了状态保持机制(会话保持机制) 实现状态保持
            
        明文传输
            http协议的内容都是不加密 直接暴露出来 传输给服务器 如果在发送的环节中任意一个步骤出现问题 被窃取就没有安全可言
            安全性低
            为了提高安全性 https诞生  https=http+ ssl/tls(加密协议)
            
            https和http区别
                https属于加密协议 更加安全  加密需要消耗资源与时间 传输速度慢  加密需要得到官方的证书承认(CA证书) 需要花钱 默认端口 443
                http相对不安全  传输速度相对较快 默认端口 80
                
状态保持机制
    cookie     
        优点:实现了状态保持  方便 
        缺点:信息数据存储在客户端 可以直接查看cookie数据 不安全 
    session  基于cookie
        优点:实现了状态保持  相对安全 用户信息存储在服务器 只返回一个随机字符串没有任何含义
        缺点:占用服务器端资源(用户信息存储在服务器)
    token 基于cookie
        token可以不使用cookie   在登陆成功的响应正文中返回一个token值 前端提取该token 
        自由决定放在哪里(woniuxy放到cookie halo是自定义了一个请求头存放token)
        如果使用cookie  cookie信息存储在本地 用户可操作
        
        优点:实现了状态保持 加用户信息加密返回一个随机字符串 相对安全 只返回一个随机字符串没有任何含义
        缺点:加解密需要消耗cpu 浪费时间  (时间换空间)
        
http协议状态码
    1**   继续
    2**   成功
    3**   重定向
    4**   客户端错误 
    5**   服务端错误 
    常见http协议状态码含义
    
    业务状态码 （每个公司业务状态码不一样） 
        出现在响应正文中  一般用 status 或者code等键 表示
        
    协议状态码是针对的http请求 他是一个独立的 出现在响应数据包第一部分 通过抓包他也有独立的菜单

常见请求方式
    get: 表示拿取获取得到的意思 一般用于查询类操作
    post:表示提交 插入 一般涉及修改类的操作 会用post
    get和post区别:
        get的查询参数一般在url中 请求正文为空  post请求的参数放在请求正文
        get请求相对不安全 参数直接在url中可见  post请求参数放在正文中
        url中不允许出现中文 所以get请求中参数会被url编码  post不会
        url存在长度限制(具体长度限制由浏览器决定) 所以get的参数有长度限制  post不会
        get一般表示查询类操作 查询不会改变数据的内容 但是post一般涉及表单参数 可能涉及到数据库的修改 
        get请求可以被历史记录 post不行 所以get请求可以被回退 post不行(防止重复提交)
    
常见头部信息
    Authorization  授权证书  当接口的头部信息出现该参数 
    Cookie   
    Content-Type   声明内容的类型 在请求头中表示请求正文类型   响应头中表示响应正文类型
        text/html ： HTML格式
        text/plain ：纯文本格式
        application/json ：JSON数据格式   
        application/x-www-form-urlencoded : 表单参数类型 在传输的时候 会变成 键=值&键2=值2&。。。
        multipart/form-data ：表单参数类型 只要涉及到文件上传 必定是该类型
    User-Agent  声明当前请求发送的设备类型
    Set-Cookie 
    Http请求的头部信息及Content-Type类型 https://www.cnblogs.com/klb561/p/10090540.html)https://www.cnblogs.com/klb561/p/10090540.html      
    
TCP/IP模型
    应用层  HTTP HTTPS  FTP SMTP 
    传输层  TCP/UDP
    网络层  IP
    访问层 
    
    TCP 是面向连接 传输可靠 不会丢包及数据错误(有数据校验) 速度慢  文字传输 或者超文本传输协议
    UDP 不面向连接 传输不稳定  传输速度快 适用于广播传输     视频语音聊天
    
    简述TCP三次握手四次挥手  为什么不是两次 不是四次
    原因很简单，因为只有三次才是最合适的，三次通信是最小值，两次通信满足不了要求，而四次通信则显得冗余。比如之前的三次改成两次，四次的结果就变味了。
        两次握手：
        “喂，你听得到吗？”
        “我听得到呀”
        “喂，你听得到吗？”
        “草，我听得到呀！！！！”
        “你TM能不能听到我讲话啊！！喂！”
        四次握手：
        “喂，你听得到吗？”
        “我听得到呀，你听得到我吗？”
        “我能听到你，你能听到我吗？”
        “……不想跟傻逼说话”
        三次握手
        “喂，你听得到吗？”
        “我听得到呀，你听得到我吗？”
        “我能听到你”

    如果现在没有接口文档 如何开展接口测试
        先尝试去跟产品和开发沟通 熟悉业务 了解有没有其他的相关文档进行参考
        基于功能 通过抓包 捕获页面的接口 然后进行接口测试  如果时间充足 我可以尝试补充接口文档 
                
    接口测试用例怎么设计：
        我们公司之前没有设计接口测试用例  直接基于功能测试用例在添加一些接口测试的特定场景(无参数,安全测试等等)
        或者基于接口文档 直接 进行一系列的接口测试用例设计
        
        如果设计接口测试用例
        围绕 业务功能测试(正常 异常场景)  然后等价类边界值针对参数进行设计 如:覆盖所有必须参数 参数有或者无或者参数不传入
            参数的长度 顺序 特殊字符  参数组合场景
            还有一些安全场景(sql注入 用户验证 信息加密)  在针对特定的接口做一些 并发测试 事务测试等

**测试工程师的面试总结万字长文**  https://testerhome.com/topics/24874

"""
